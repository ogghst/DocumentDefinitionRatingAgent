<!DOCTYPE html>
<html>
<head>
    <title>Checklist Assistant</title>
    <!-- Add markdown-it library for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js"></script>
    <!-- Add Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Light Theme (Default) */
        :root {
            --bg-color: #ffffff;
            --text-color: #212529;
            --text-light: #6c757d;
            --primary-color: #0d6efd;
            --secondary-color: #6c757d;
            --accent-color: #6f42c1;
            --success-color: #198754;
            --warning-color: #ffc107;
            --error-color: #dc3545;
            --border-color: #dee2e6;
            --card-bg: #ffffff;
            --message-user-bg: var(--primary-color);
            --message-user-text: #ffffff;
            --message-ai-bg: #f8f9fa;
            --message-ai-text: var(--text-color);
            --reasoning-bg: #e9ecef;
            --reasoning-text: #495057;
            --code-bg: #e9ecef;
            --input-bg: #ffffff;
        }

        /* Dark Theme */
        body.dark-mode {
            --bg-color: #212529;
            --text-color: #f8f9fa;
            --text-light: #adb5bd;
            --primary-color: #4dabf7;
            --secondary-color: #adb5bd;
            --accent-color: #da77f2;
            --success-color: #40c057;
            --warning-color: #ffc107;
            --error-color: #ff6b6b;
            --border-color: #495057;
            --card-bg: #343a40;
            --message-user-bg: var(--primary-color);
            --message-user-text: #212529;
            --message-ai-bg: #343a40;
            --message-ai-text: var(--text-color);
            --reasoning-bg: #495057;
            --reasoning-text: #ced4da;
            --code-bg: #495057;
            --input-bg: #495057;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        h1 {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0; /* Removed margin as it's in header */
            font-size: 1.8em;
        }
        
        .container {
            max-width: 1200px; /* Narrower for minimalist */
            width: 100%;
            margin: 20px auto;
            padding: 0; /* Remove padding, handled by sections */
            background-color: transparent; /* Container is transparent */
            border-radius: 0;
            box-shadow: none;
        }
        
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 500;
            color: var(--text-light);
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }
        
        .status-badge.connected {
            color: var(--success-color);
            border-color: var(--success-color);
            background-color: transparent;
        }
        
        #connection-status {
            font-weight: 500;
        }
        
        /* Minimalist Message Area */
        #messages {
            height: 80vh; /* Relative height */
            overflow-y: scroll;
            margin-bottom: 20px;
            padding: 10px; /* Minimal padding */
            background-color: transparent; /* Transparent background */
            border-radius: 0;
            box-shadow: none;
            border: none;
        }
        
        /* Base message styling */
        .message {
            padding: 10px 15px;
            margin-bottom: 15px;
            max-width: 85%;
            border-radius: 8px;
            line-height: 1.5;
            transition: background-color 0.3s ease, color 0.3s ease;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            box-shadow: none;
            position: relative;
        }
        
        /* User Message */
        .message.user {
            background: var(--message-user-bg);
            color: var(--message-user-text);
            margin-left: auto;
            margin-right: 0;
            border-color: transparent; /* No border for user */
            border-radius: 8px 8px 0 8px;
        }
        
        /* System Message */
        .message.system {
            color: var(--text-light);
            background: transparent;
            margin: 15px auto;
            max-width: 80%;
            text-align: center;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
            border: none;
            border-top: 1px dashed var(--border-color);
            border-bottom: 1px dashed var(--border-color);
            border-radius: 0;
        }
        
        /* AI/RAG Message */
        .message:not(.user):not(.system):not(.log-message) {
            background: var(--message-ai-bg);
            color: var(--message-ai-text);
            margin-right: auto;
            margin-left: 0;
            border: 1px solid var(--border-color);
            border-radius: 8px 8px 8px 0;
        }
        
        /* Log Message */
         .message.log-message {
            font-size: 0.8em;
            color: var(--text-light);
            background: transparent;
            border: 1px dashed var(--border-color);
            opacity: 0.7;
            margin-top: 5px;
            margin-bottom: 5px;
         }

        /* Message Type Label */
        .message-type {
            font-weight: 600;
            color: var(--secondary-color);
            display: block;
            margin-bottom: 5px;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Minimalist Button Style */
        button {
            padding: 8px 15px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-family: inherit;
            font-weight: 500;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
            background: var(--bg-color);
            color: var(--text-color);
            box-shadow: none;
        }
        
        button:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            background-color: transparent;
        }
        
        button:active {
            background-color: var(--border-color);
            color: var(--text-color);
            transform: none;
        }
        
        /* Specific Button Styles */
        button#start-btn {
            color: var(--success-color);
            border-color: var(--success-color);
        }
        button#start-btn:hover {
            background-color: var(--success-color);
            color: var(--bg-color);
        }
        button#submitResponseBtn {
            color: var(--accent-color);
            border-color: var(--accent-color);
            float: right; /* Align right */
        }
        button#submitResponseBtn:hover {
             background-color: var(--accent-color);
            color: var(--bg-color);
        }
        button#theme-toggle-btn {
            background: transparent;
            border: none;
            font-size: 1.2em;
            padding: 5px;
            line-height: 1;
        }
        button#theme-toggle-btn:hover {
             color: var(--primary-color);
             background-color: transparent;
        }

        /* Minimalist Input/Textarea Style */
        input, textarea {
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-family: inherit;
            font-size: 0.95em;
            width: 100%;
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
            box-shadow: none;
        }
        
        input:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: none;
        }
        
        /* Input Group (Removed, no longer needed) */
        
        /* Reasoning Block Styling */
        .reasoning-block {
            background-color: var(--reasoning-bg);
            color: var(--reasoning-text);
            border-radius: 4px;
            padding: 10px 15px;
            margin: 10px 0;
            font-style: normal; /* Not italic by default */
            font-size: 0.9em;
            border: 1px dashed var(--border-color);
            position: relative;
            box-shadow: none;
        }
        
        /* Optional: Add a subtle icon or border */
        .reasoning-block::before {
            content: "💡"; /* Simple indicator */
            position: absolute;
            left: -20px; /* Position outside */
            top: 10px;
            font-size: 0.9em;
            color: var(--secondary-color);
        }
        .reasoning-block::after { content: none; } /* Remove previous after style */
        
        
        /* Waiting Indicator */
        .rag_waiting {
            background: transparent;
            color: var(--warning-color);
            border: none;
            padding: 10px 0;
            text-align: center;
            margin: 15px auto;
            max-width: 80%;
            font-weight: 500;
            border-radius: 0;
            border-bottom: 1px dashed var(--warning-color);
            animation: none;
            box-shadow: none;
        }
        
        /* Minimalist Token Stream Container */
        .token-message {
            background: var(--message-ai-bg);
            color: var(--message-ai-text);
            border: 1px solid var(--border-color);
            border-radius: 8px 8px 8px 0;
        }
        /* Token Stream Text */
        .token-stream { display: none; } /* Hide the raw token div */
        
        /* Minimalist Input Response Form */
        #inputResponseForm {
            display: none;
            border: none;
            padding: 20px;
            margin: 20px 0;
            background: var(--card-bg);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: none;
        }
        
        #inputResponseForm .input-prompt {
             margin-bottom: 10px;
             font-weight: 500;
        }
        
        /* Minimalist Markdown Styling */
        .markdown-content { /* Applied within messages */
            line-height: 1.6;
            word-wrap: break-word;
        }
        
        .markdown-content h1, 
        .markdown-content h2,
        .markdown-content h3, 
        .markdown-content h4, 
        .markdown-content h5, 
        .markdown-content h6 {
            margin-top: 1em;
            margin-bottom: 0.5em;
            font-weight: 600;
            line-height: 1.3;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.2em;
        }
        .markdown-content h1 { font-size: 1.3em; }
        .markdown-content h2 { font-size: 1.2em; }
        .markdown-content h3 { font-size: 1.1em; }
        
        .markdown-content code {
            padding: 0.2em 0.4em;
            margin: 0 1px;
            font-size: 85%;
            background-color: var(--code-bg);
            border-radius: 3px;
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
            color: var(--text-color);
        }
        
        .markdown-content pre {
            background-color: var(--code-bg);
            border-radius: 4px;
            padding: 12px;
            overflow: auto;
            margin: 0.8em 0;
            border: 1px solid var(--border-color);
        }
        
        .markdown-content pre code {
            background-color: transparent;
            padding: 0;
            margin: 0;
            border: none;
        }
        
        .markdown-content blockquote {
            padding: 0.5em 1em;
            color: var(--text-light);
            border-left: 3px solid var(--secondary-color);
            margin: 0.8em 0;
            background-color: transparent;
            border-radius: 0;
        }
        
        .markdown-content table {
            border-collapse: collapse;
            width: auto; /* Don't force full width */
            margin: 1em 0;
            border: 1px solid var(--border-color);
            box-shadow: none;
            border-radius: 0;
            overflow: hidden;
        }
        
        .markdown-content th, 
        .markdown-content td {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            text-align: left;
        }
        
        .markdown-content th {
            background-color: var(--message-ai-bg);
            font-weight: 600;
        }
        
        .markdown-content tr:nth-child(even) td {
            background-color: transparent; /* Simpler table */
        }
        
        .markdown-hints {
            background-color: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            padding: 8px 10px;
            font-size: 0.85em;
            color: var(--text-light);
            margin-top: 10px;
            box-shadow: none;
        }
        
        .markdown-hints code {
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-size: inherit;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            box-shadow: none;
        }
        
        /* Minimalist animation */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .message {
            animation: fadeIn 0.3s ease-out;
        }
        
        /* Styling for Check Start message table */
        .check-details-table {
            width: 100%;
            margin-top: 8px;
            border-collapse: collapse;
            font-size: 0.9em;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color); /* Match card bg */
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        
        .check-details-table th,
        .check-details-table td {
            text-align: left;
            padding: 6px 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .check-details-table th {
            font-weight: 600;
            width: 100px; /* Fixed width for labels */
            background-color: var(--message-ai-bg); /* Match AI message header */
            color: var(--secondary-color);
        }
        
        .check-details-table td {
            word-break: break-word;
        }
        
        .check-details-table tr:last-child th,
        .check-details-table tr:last-child td {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Checklist Assistant</h1>
            <div class="header-controls">
                <div id="connection-status" class="status-badge">Disconnected</div>
                <button id="start-btn">Start Analysis</button>
                <button id="theme-toggle-btn">🌙</button> 
            </div>
        </div>
    
    <div id="conversation" style="display:block;">
        <div id="messages"></div>
            
            <div id="inputResponseForm">
                <div class="input-prompt"></div>
                <textarea id="responseInput" rows="5" placeholder="Enter your response here..."></textarea>
                <div class="markdown-hints">
                    <strong>Markdown formatting:</strong> 
                    <code># Heading</code> 
                    <code>**bold**</code> 
                    <code>*italic*</code> 
                    <code>- list</code> 
                    <code>[link](url)</code> 
                    <code>```code```</code>
                </div>
                <div style="margin-top: 12px; text-align: right;">
                    <button id="submitResponseBtn">Submit Response</button>
                </div>
            </div>
        
    </div>
    </div>
    
    <script>
        // Debug client with explicit token handling
        const API_URL = 'http://localhost:8765';
        let socket = null;
        let currentConversationId = null;
        let isStreamingTokens = false;
        let currentStreamDiv = null;
        let currentMarkdownDiv = null; // For regular streaming content
        let currentReasoningDiv = null; // For reasoning block content
        let isInsideThinkTag = false; // State to track if we are inside <think> tags
        
        const messagesDiv = document.getElementById('messages');
        const statusDiv = document.getElementById('connection-status');
        const conversationDiv = document.getElementById('conversation');
        const responseInput = document.getElementById('responseInput');
        const inputResponseForm = document.getElementById('inputResponseForm');
        const startBtn = document.getElementById('start-btn');
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        
        // Initialize markdown-it parser
        const md = window.markdownit({
            html: false,        // Disable HTML tags in source
            breaks: true,       // Convert '\n' in paragraphs into <br>
            linkify: true,      // Autoconvert URL-like text to links
            typographer: true   // Enable some language-neutral replacement + quotes beautification
        });
        
        // Connect to a conversation
        async function connectToConversation(id) {
            // Close any existing connection
            if (socket) {
                socket.close();
            }
            
            try {
                // Get conversation details
                const response = await fetch(`${API_URL}/conversations/${id}`);
                if (!response.ok) {
                    throw new Error('Conversation not found');
                }
                
                const conversation = await response.json();
                currentConversationId = id;
                
                // Update UI
                conversationDiv.style.display = 'block';
                messagesDiv.innerHTML = '<div class="message system">Connecting...</div>';
                isStreamingTokens = false;
                currentStreamDiv = null;
                
                // Connect WebSocket
                socket = new WebSocket(`ws://localhost:8765/ws/${id}`);
                
                // Log all events for debugging
                socket.onopen = (event) => {
                    statusDiv.textContent = 'Connected';
                    statusDiv.classList.add('connected');
                    addSystemMessage('WebSocket connected');
                    // Automatically start RAG after connection
                    startRagAnalysisInternal(); 
                };
                
                socket.onclose = (event) => {
                    statusDiv.textContent = 'Disconnected';
                    statusDiv.classList.remove('connected');
                    addSystemMessage(`WebSocket closed: ${event.code} ${event.reason}`);
                };
                
                socket.onerror = (error) => {
                    statusDiv.textContent = 'Error';
                    statusDiv.classList.remove('connected');
                    addSystemMessage('WebSocket error: ' + JSON.stringify(error));
                };
                
                // Handle ALL messages with special handling for tokens
                socket.onmessage = (event) => {
                    const rawData = event.data;
                    
                    try {
                        // Try to parse it as JSON
                        const message = JSON.parse(rawData);
                        
                        // Process tokens with highest priority
                        if (message.type === 'rag_token') {
                            // Use requestAnimationFrame for smoother UI updates
                            window.requestAnimationFrame(() => {
                                handleToken(message.content);
                            });
                            return;
                        }
                        
                        // Handle input requests
                        if (message.type === 'input_request') {
                            console.log('INPUT REQUEST:', message.content);
                            // End any active token stream
                            finishTokenStream();
                            showInputRequestForm(message.content);
                            return;
                        }
                        
                        // Handle errors
                        if (message.type === 'error') {
                            // End any active token stream
                            finishTokenStream();
                            
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'message error';
                            errorDiv.style.color = 'var(--error-color)';
                            errorDiv.textContent = `Error: ${message.content}`;
                            messagesDiv.appendChild(errorDiv);
                            scrollToBottom();
                            return;
                        }
                        
                        // Check for waiting messages
                        if (message.type === 'rag_progress' && 
                            message.content.includes('Waiting for human input')) {
                            // End any active token stream
                            finishTokenStream();
                            
                            // Add a special waiting indicator
                            const waitingDiv = document.createElement('div');
                            waitingDiv.className = 'message rag_waiting';
                            waitingDiv.textContent = message.content;
                            messagesDiv.appendChild(waitingDiv);
                            scrollToBottom();
                            return;
                        }
                        
                        // For all other message types
                        // End any active token stream first
                        finishTokenStream();
                        displayMessage(message);
                    } catch (error) {
                        // If parsing fails, it's a log message
                        finishTokenStream();
                        displayLogMessage(rawData);
                    }
                };
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
        
        // Unified token handler that displays in the messages area
        function handleToken(token) {
            // If not currently streaming, start a new container
            if (!isStreamingTokens || !currentMarkdownDiv) {
                startNewTokenStream(); 
            }

            // Buffer incomplete tags across tokens
            let currentBuffer = (currentMarkdownDiv.dataset.buffer || "") + token;
            
            let processedToken = "";
            let tagFound = false;
            
            // Process buffer for tags
            while (true) {
                tagFound = false;
                let thinkStart = currentBuffer.indexOf("<think>");
                let thinkEnd = currentBuffer.indexOf("</think>");

                if (isInsideThinkTag) {
                    // Currently inside a think block, look for end tag
                    if (thinkEnd !== -1) {
                        // Append content before the end tag to reasoning block
                        processedToken = currentBuffer.substring(0, thinkEnd);
                        if (processedToken) appendToStream(processedToken, true);
                        
                        currentBuffer = currentBuffer.substring(thinkEnd + "</think>".length);
                        isInsideThinkTag = false;
                        // Do not reset currentReasoningDiv here, it refers to the active stream block
                        tagFound = true;
                    } else {
                        // End tag not found in buffer, append entire buffer to reasoning
                        appendToStream(currentBuffer, true);
                        currentBuffer = ""; // Clear buffer
                        break; // Wait for more tokens
                    }
                } else {
                    // Currently outside a think block, look for start tag
                    if (thinkStart !== -1) {
                        // Append content before the start tag to markdown block
                        processedToken = currentBuffer.substring(0, thinkStart);
                        if (processedToken) appendToStream(processedToken, false);
                        
                        currentBuffer = currentBuffer.substring(thinkStart + "<think>".length);
                        isInsideThinkTag = true;
                        // Ensure reasoning div exists and set it as current target
                         ensureReasoningDivExists(); 
                        tagFound = true;
                    } else {
                        // Start tag not found, append entire buffer to markdown
                        appendToStream(currentBuffer, false);
                        currentBuffer = ""; // Clear buffer
                        break; // Wait for more tokens
                    }
                }
                
                if (!tagFound) break; // No more tags in the current buffer chunk
            }
            
            // Store remaining buffer for the next token
            currentMarkdownDiv.dataset.buffer = currentBuffer;
            
            scrollToBottom();
        }
        
        // Helper to append token content to the correct div (markdown or reasoning)
        function appendToStream(content, isReasoning) {
             if (!content) return;

             let targetDiv = isReasoning ? currentReasoningDiv : currentMarkdownDiv;
             
             // If target is reasoning but div doesn't exist yet, create it
             if (isReasoning && !targetDiv) { 
                 ensureReasoningDivExists();
                 targetDiv = currentReasoningDiv; 
             }

             if (targetDiv) {
                // Append raw text. Rendering happens in finishTokenStream.
                targetDiv.textContent += content;
             } else if (!isReasoning && currentMarkdownDiv) {
                // Fallback to markdown div if reasoning target somehow failed 
                currentMarkdownDiv.textContent += content; 
             } else {
                 console.error("Target div for streaming not found! Content:", content, "Is Reasoning:", isReasoning);
             }
        }
        
        // Helper to create the reasoning div if it doesn't exist during streaming
        function ensureReasoningDivExists() {
            if (!currentReasoningDiv && currentMarkdownDiv) {
                 // Check if it already exists from a previous token in the same message
                 let existingReasoningDiv = currentMarkdownDiv.parentElement.querySelector('.reasoning-block-stream');
                 if (existingReasoningDiv) {
                     currentReasoningDiv = existingReasoningDiv;
                 } else {
                     // Create it
                     currentReasoningDiv = document.createElement('div');
                     currentReasoningDiv.className = 'reasoning-block reasoning-block-stream'; 
                     currentMarkdownDiv.parentElement.appendChild(currentReasoningDiv);
                 }
            }
        }
        
        // Start a new token stream in the messages area
        function startNewTokenStream() {
            // Create a container for the token stream message
            const streamContainer = document.createElement('div');
            streamContainer.className = 'message token-message'; // Use a specific class
            
            // Add message type label
            const typeSpan = document.createElement('span');
            typeSpan.className = 'message-type';
            typeSpan.textContent = 'RAG'; // Or derive dynamically if needed
            streamContainer.appendChild(typeSpan);
            
            // Create div for the main markdown content (target for non-reasoning text)
            const markdownDiv = document.createElement('div');
            markdownDiv.className = 'markdown-content markdown-content-stream'; 
            streamContainer.appendChild(markdownDiv);
            
            // Reasoning div is created dynamically by appendToStream/ensureReasoningDivExists if needed

            // Add to messages
            messagesDiv.appendChild(streamContainer);
            
            // Set the current stream references
            currentMarkdownDiv = markdownDiv; 
            currentReasoningDiv = null; // Reset reasoning div reference for the new message
            isStreamingTokens = true;
            isInsideThinkTag = false; // Reset state
            currentMarkdownDiv.dataset.buffer = ""; // Initialize buffer
            
            scrollToBottom();
        }
        
        // Finish the current token stream
        function finishTokenStream() {
            if (isStreamingTokens && currentMarkdownDiv) { // Check primary markdown div
                console.log('Finishing token stream');
                isStreamingTokens = false; 
                isInsideThinkTag = false;

                // Process any remaining buffer
                let remainingBuffer = currentMarkdownDiv.dataset.buffer || "";
                if (remainingBuffer) {
                    appendToStream(remainingBuffer, isInsideThinkTag); // Append to correct div
                    currentMarkdownDiv.dataset.buffer = "";
                }

                // Final rendering of markdown content
                if (currentMarkdownDiv.textContent) {
                    try {
                         currentMarkdownDiv.innerHTML = md.render(currentMarkdownDiv.textContent.trim());
                         currentMarkdownDiv.classList.remove('markdown-content-stream'); // Remove stream class
                    } catch (e) {
                        console.error("Error rendering final markdown stream:", e);
                    }
                }
                
                // Final rendering of reasoning content
                const reasoningDiv = currentMarkdownDiv.parentElement.querySelector('.reasoning-block-stream');
                if (reasoningDiv && reasoningDiv.textContent) {
                     try {
                         // Render markdown inside the reasoning block as well
                         reasoningDiv.innerHTML = md.render(reasoningDiv.textContent.trim());
                         reasoningDiv.classList.remove('reasoning-block-stream'); // Remove stream class
                    } catch (e) {
                        console.error("Error rendering final reasoning stream:", e);
                    }
                }
                
                // Clear references 
                currentMarkdownDiv = null;
                currentReasoningDiv = null;
                
                scrollToBottom();
            }
            // Ensure state is reset even if stream ended unexpectedly
            isStreamingTokens = false; 
            isInsideThinkTag = false;
            currentMarkdownDiv = null;
            currentReasoningDiv = null;
        }
        
        // Create a new conversation
        async function createConversationInternal() {
            try {
                const response = await fetch(`${API_URL}/conversations`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        title: 'New Conversation',
                        checklist_path: 'checklists/project_checklist_demo.xlsx',
                        document_path: 'input/quotation_demo.docx',
                        target_phase: 'Apertura Commessa'
                    })
                });
                
                const data = await response.json();
                return data.id; // Return the new ID
            } catch (error) {
                alert('Error creating conversation: ' + error.message);
                return null; // Indicate failure
            }
        }
        
        // Start RAG analysis
        async function startRagAnalysisInternal() {
            if (!currentConversationId || !socket || socket.readyState !== WebSocket.OPEN) {
                console.error("Cannot start RAG: Not connected or missing ID.");
                addSystemMessage("Error: Could not start analysis. Connection failed.");
                startBtn.disabled = false;
                startBtn.textContent = 'Start Analysis';
                return;
            }
            
            try {
                // UI update is already done by the initial start function
                addSystemMessage('Starting RAG analysis...');
                
                await fetch(`${API_URL}/conversations/${currentConversationId}/start`, {
                    method: 'POST'
                });
                
                addSystemMessage('RAG analysis requested');
                // No need to re-enable button here, it stays disabled during analysis
            } catch (error) {
                alert('Error starting RAG analysis: ' + error.message);
                addSystemMessage('Error starting analysis: ' + error.message);
                // Re-enable button on error
                startBtn.disabled = false;
                startBtn.textContent = 'Start Analysis';
            }
        }
        
        // Initial function called by the Start button
        async function startProcess() {
             if (startBtn.disabled) return; // Prevent double clicks

             startBtn.disabled = true;
             startBtn.textContent = 'Starting...';
             messagesDiv.innerHTML = ''; // Clear previous messages
             addSystemMessage("Creating new conversation...");

             const newConversationId = await createConversationInternal();

             if (newConversationId) {
                 addSystemMessage(`Conversation ${newConversationId} created. Connecting...`);
                 // connectToConversation will call startRagAnalysisInternal on successful connection
                 connectToConversation(newConversationId); 
             } else {
                 addSystemMessage("Failed to create conversation.");
                 startBtn.disabled = false;
                 startBtn.textContent = 'Start Analysis';
             }
        }
        
        // Display a parsed JSON message
        function displayMessage(message) {
            const div = document.createElement('div');
            div.className = 'message';
            
            // Add type-specific classes
            if (message.type) {
                div.classList.add(message.type.toLowerCase()); 
            }
            
            // For user messages, use a different style
            if (message.type === 'user') {
                // Create content container
                const contentDiv = document.createElement('div');
                contentDiv.className = 'markdown-content';
                contentDiv.innerHTML = md.render(message.content);
                div.appendChild(contentDiv);
            } else {
                // Create type label for non-user messages
                const typeSpan = document.createElement('span');
                typeSpan.className = 'message-type';
                // Display type nicely (e.g., rag_progress -> RAG Progress)
                typeSpan.textContent = (message.type || 'unknown').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                div.appendChild(typeSpan);
            
                // Create content container
                const contentContainer = document.createElement('div');
            
                // Handle different content types
                if (message.type === 'check_start') {
                    try {
                        const checkData = JSON.parse(message.content);
                        const table = document.createElement('table');
                        table.className = 'check-details-table';
                        
                        // Define order and labels
                        const fieldsToShow = [
                            { key: 'id', label: 'ID' },
                            { key: 'name', label: 'Name' },
                            { key: 'description', label: 'Description' },
                            { key: 'branch_name', label: 'Branch' },
                            { key: 'weight', label: 'Weight' },
                            { key: 'phase', label: 'Phase' },
                        ];
                        
                        fieldsToShow.forEach(field => {
                            if (checkData.hasOwnProperty(field.key)) {
                                const row = table.insertRow();
                                const th = document.createElement('th');
                                const td = document.createElement('td');
                                th.textContent = field.label;
                                // Render description as markdown if it's the description field
                                if (field.key === 'description') {
                                    td.innerHTML = md.render(checkData[field.key]);
                                } else {
                                    td.textContent = checkData[field.key];
                                }
                                row.appendChild(th);
                                row.appendChild(td);
                            }
                        });
                        contentContainer.appendChild(table);
                        
                    } catch (e) {
                        console.error("Error parsing check_start content:", e);
                        // Fallback to rendering raw content if parsing fails
                        renderMarkdownWithReasoning(message.content, contentContainer);
                    }
                } else if (message.type === 'RAG_RESULT') {
                     // Try to parse and pretty-print JSON for RAG_RESULT
                     try {
                         const parsedJson = JSON.parse(message.content);
                         
                         // Create a container for all check results
                         const resultsContainer = document.createElement('div');
                         resultsContainer.className = 'check-results-container';
                         
                         // Handle both single result and array of results
                         const results = Array.isArray(parsedJson) ? parsedJson : [parsedJson];
                         
                         results.forEach(result => {
                             // Create a box for each check result
                             const resultBox = document.createElement('div');
                             resultBox.className = 'check-result-box';
                             
                             // Create table for structured display
                             const table = document.createElement('table');
                             table.className = 'check-result-table';
                             
                             // Add rows for each CheckResult field
                             const fields = [
                                 { label: 'Check ID', value: result.check_item?.id || 'N/A' },
                                 { label: 'Check Name', value: result.check_item?.name || 'N/A' },
                                 { label: 'Status', value: result.is_met ? 'Met' : 'Not Met' },
                                 { label: 'Reliability', value: `${result.reliability}%` },
                                 { label: 'Human Review', value: result.needs_human_review ? 'Required' : 'Not Required' },
                                 { label: 'User Input', value: result.user_input || 'None' }
                             ];
                             
                             fields.forEach(field => {
                                 const row = table.insertRow();
                                 const labelCell = row.insertCell(0);
                                 const valueCell = row.insertCell(1);
                                 
                                 labelCell.className = 'field-label';
                                 valueCell.className = 'field-value';
                                 
                                 labelCell.textContent = field.label;
                                 valueCell.textContent = field.value;
                             });
                             
                             // Add analysis details if present
                             if (result.analysis_details) {
                                 const detailsRow = table.insertRow();
                                 const detailsCell = detailsRow.insertCell(0);
                                 detailsCell.colSpan = 2;
                                 detailsCell.className = 'analysis-details';
                                 detailsCell.innerHTML = md.render(result.analysis_details);
                             }
                             
                             // Add sources if present
                             if (result.sources && result.sources.length > 0) {
                                 const sourcesRow = table.insertRow();
                                 const sourcesCell = sourcesRow.insertCell(0);
                                 sourcesCell.colSpan = 2;
                                 sourcesCell.className = 'sources';
                                 
                                 const sourcesList = document.createElement('ul');
                                 result.sources.forEach(source => {
                                     const li = document.createElement('li');
                                     li.textContent = source;
                                     sourcesList.appendChild(li);
                                 });
                                 sourcesCell.appendChild(sourcesList);
                             }
                             
                             resultBox.appendChild(table);
                             resultsContainer.appendChild(resultBox);
                         });
                         
                         contentContainer.appendChild(resultsContainer);
                         
                     } catch (e) {
                         // If parsing fails, display as markdown (which might contain think tags)
                         console.warn("RAG_RESULT content was not valid JSON, rendering as markdown:", message.content);
                         renderMarkdownWithReasoning(message.content, contentContainer); 
                     }
                } else if (typeof message.content === 'string') {
                     // Process other string content for <think> tags (non-streaming)
                     renderMarkdownWithReasoning(message.content, contentContainer); 
                } else { // If content is not a string (e.g., object for errors sometimes)
                    contentContainer.innerHTML = '<pre>' + JSON.stringify(message.content, null, 2) + '</pre>';
                }
                
                div.appendChild(typeSpan);
                div.appendChild(contentContainer); 
            }
            
            // Add timestamp if available
            if (message.timestamp) {
                const time = new Date(message.timestamp).toLocaleTimeString();
                div.title = time;
            }
            
            messagesDiv.appendChild(div);
            scrollToBottom();
        }
        
        // Helper function to render markdown string containing potential <think> tags (for non-streaming messages)
        function renderMarkdownWithReasoning(content, targetElement) {
            targetElement.innerHTML = ''; // Clear existing content
            const reasoningRegex = /<think>([\s\S]*?)<\/think>/g; // Corrected Regex
            let lastIndex = 0;
            let match;

            while ((match = reasoningRegex.exec(content)) !== null) {
                // Add content before the tag as markdown
                if (match.index > lastIndex) {
                    const markdownPart = content.substring(lastIndex, match.index);
                    const markdownDiv = document.createElement('div');
                    markdownDiv.className = 'markdown-content';
                    markdownDiv.innerHTML = md.render(markdownPart.trim());
                    targetElement.appendChild(markdownDiv);
                }
                
                // Add the reasoning block as markdown
                const reasoningContent = match[1];
                const reasoningDiv = document.createElement('div');
                reasoningDiv.className = 'reasoning-block';
                reasoningDiv.innerHTML = md.render(reasoningContent.trim()); // Render markdown inside
                targetElement.appendChild(reasoningDiv);
                
                lastIndex = reasoningRegex.lastIndex;
            }
            
            // Add any remaining content after the last tag as markdown
            if (lastIndex < content.length) {
                const markdownPart = content.substring(lastIndex);
                const markdownDiv = document.createElement('div');
                markdownDiv.className = 'markdown-content';
                markdownDiv.innerHTML = md.render(markdownPart.trim());
                targetElement.appendChild(markdownDiv);
            }
            
             // Handle cases where the entire content might be empty or just tags
             if (targetElement.innerHTML.trim() === '') {
                 targetElement.innerHTML = '<em>(Empty message)</em>';
             }
        }
        
        // Display a log message with better formatting
        function displayLogMessage(message) {
            const div = document.createElement('div');
            div.className = 'message log-message';
            
            const typeSpan = document.createElement('span');
            typeSpan.className = 'message-type';
            typeSpan.textContent = 'log';
            
            div.appendChild(typeSpan);
            div.appendChild(document.createTextNode(' ' + message));
            
            messagesDiv.appendChild(div);
            scrollToBottom();
        }
        
        // Add a system message (client-generated)
        function addSystemMessage(content) {
            const div = document.createElement('div');
            div.className = 'message';
            div.textContent = content;
            
            messagesDiv.appendChild(div);
            scrollToBottom();
        }
        
        // Handle input requests from the RAG system
        function showInputRequestForm(message) {
            // Display the input form
            inputResponseForm.style.display = 'block';

            // --- Edit Start: Improved Prompt Rendering ---
            // Get the input-prompt element and clear it
            const inputPromptElement = inputResponseForm.querySelector('.input-prompt');
            inputPromptElement.innerHTML = ''; // Clear previous content

            // Create a container for the prompt content
            const promptContainer = document.createElement('div');
            promptContainer.className = 'markdown-content'; // Use markdown styling

            // Render the prompt, making <think> tags collapsible
            const reasoningRegex = /<think>([\s\S]*?)<\/think>/g;
            let lastIndex = 0;
            let match;

            while ((match = reasoningRegex.exec(message)) !== null) {
                // Add content before the tag as markdown
                if (match.index > lastIndex) {
                    const markdownPart = message.substring(lastIndex, match.index);
                    const markdownDiv = document.createElement('div');
                    // Render normal markdown - no extra bolding applied here by default
                    markdownDiv.innerHTML = md.render(markdownPart.trim());
                    promptContainer.appendChild(markdownDiv);
                }

                // Add the reasoning block within a collapsible <details> tag
                const reasoningContent = match[1];
                const detailsElement = document.createElement('details');
                detailsElement.style.marginTop = '10px'; // Add some spacing
                detailsElement.style.marginBottom = '10px';

                const summaryElement = document.createElement('summary');
                summaryElement.textContent = 'Show Reasoning'; // Clickable text
                summaryElement.style.cursor = 'pointer';
                summaryElement.style.fontWeight = '500'; // Slightly bolder summary
                summaryElement.style.color = 'var(--secondary-color)';

                const reasoningDiv = document.createElement('div');
                reasoningDiv.className = 'reasoning-block'; // Reuse existing reasoning style
                reasoningDiv.style.marginTop = '5px'; // Space below summary
                reasoningDiv.innerHTML = md.render(reasoningContent.trim()); // Render markdown inside

                detailsElement.appendChild(summaryElement);
                detailsElement.appendChild(reasoningDiv);
                promptContainer.appendChild(detailsElement);

                lastIndex = reasoningRegex.lastIndex;
            }

            // Add any remaining content after the last tag as markdown
            if (lastIndex < message.length) {
                const markdownPart = message.substring(lastIndex);
                const markdownDiv = document.createElement('div');
                 // Render normal markdown
                markdownDiv.innerHTML = md.render(markdownPart.trim());
                promptContainer.appendChild(markdownDiv);
            }

             // Handle cases where the entire content might be empty or just tags
             if (promptContainer.innerHTML.trim() === '') {
                 promptContainer.innerHTML = '<em>(Empty prompt)</em>';
             }

            // Add the rendered prompt content to the input-prompt div
            inputPromptElement.appendChild(promptContainer);

            // Add the note about Markdown formatting separately
             const markdownHintPara = document.createElement('p');
             markdownHintPara.innerHTML = '<em>You can use Markdown formatting in your response.</em>';
             markdownHintPara.style.fontSize = '0.9em';
             markdownHintPara.style.color = 'var(--text-light)';
             inputPromptElement.appendChild(markdownHintPara);
             // --- Edit End ---

            // Focus the textarea for input
            responseInput.focus();
            
            // Scroll to the input form
            inputResponseForm.scrollIntoView({ behavior: 'smooth' });
            
            // Add visual indicator that system is waiting
            const waitingIndicator = document.createElement('div');
            waitingIndicator.className = 'message rag_waiting';
            waitingIndicator.textContent = 'RAG Analysis Paused: Waiting for your input...';
            messagesDiv.appendChild(waitingIndicator);
            scrollToBottom();
        }
        
        // Submit response for the input request
        function submitResponse() {
            console.log("Submit response function called");
            
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                console.error("Cannot submit response: Socket not connected");
                alert("Cannot submit response: Not connected to server");
                return;
            }
            
            const content = responseInput.value.trim();
            console.log("Response content:", content ? content.substring(0, 50) + "..." : "(empty)");
            
            if (!content) {
                // If empty, ask for confirmation before skipping
                if (!confirm('You haven\'t entered any response. Do you want to skip this question?')) {
                    return;
                }
                console.log("User confirmed skipping the question");
            }
            
            try {
            // Send via WebSocket with the input_response type
                const message = JSON.stringify({
                type: 'input_response',
                content: content || 'skip' 
                });
                console.log("Sending message:", message);
                socket.send(message);
            
            // Add user's response to message history
            const responseDiv = document.createElement('div');
            responseDiv.className = 'message user';
                
                // Create a container for formatted content
                const responseContent = document.createElement('div');
                responseContent.className = 'markdown-content';
                
                // Add markdown-rendered content (no <think> tags expected in user input)
                responseContent.innerHTML = content ? md.render(content) : '<em>(skipped)</em>';
                
                responseDiv.appendChild(responseContent);
            messagesDiv.appendChild(responseDiv);
            
            // Hide the input form and clear it
            inputResponseForm.style.display = 'none';
            responseInput.value = '';
            
            // Add a message that we've submitted
            const submitDiv = document.createElement('div');
            submitDiv.className = 'message system';
                submitDiv.textContent = 'Response submitted. RAG analysis continuing...';
            messagesDiv.appendChild(submitDiv);
            
            scrollToBottom();
                console.log("Response successfully submitted");
            } catch (error) {
                console.error("Error submitting response:", error);
                alert("Error submitting response: " + error.message);
            }
        }
        
        // Event listeners
        startBtn.addEventListener('click', startProcess);
        
        // Make sure the submitResponseBtn listener is properly set up
        const submitResponseBtn = document.getElementById('submitResponseBtn');
        if (submitResponseBtn) {
            submitResponseBtn.addEventListener('click', submitResponse);
            console.log("Submit response button event listener attached");
        } else {
            console.error("Submit response button not found in the DOM");
        }
        
        // Dark Mode Toggle Logic
        themeToggleBtn.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            // Update button icon based on theme
            if (document.body.classList.contains('dark-mode')) {
                themeToggleBtn.textContent = '☀️'; // Sun icon for dark mode
                localStorage.setItem('theme', 'dark'); // Save preference
            } else {
                themeToggleBtn.textContent = '🌙'; // Moon icon for light mode
                localStorage.setItem('theme', 'light'); // Save preference
            }
        });
        
        // Apply saved theme on load
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-mode');
            themeToggleBtn.textContent = '☀️';
        } else {
             document.body.classList.remove('dark-mode'); // Ensure light mode if not dark
             themeToggleBtn.textContent = '🌙';
        }
        
        // Helper function to scroll messages to bottom
        function scrollToBottom() {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
    </script>
</body>
</html>